/**
 * Url: https://app.codesignal.com/challenge/gxfSxR6EESyhSLuQx
 * 
 * Given a network of cities (undirected), each vertex represents a city, what
 * city if removed would returns the maximum number of isolated islands (no
 * matter what their size they'll count as one).
 * 
 * Example 1
 * 
 * i represents the city, connections[i] represents the connections from that
 * city. [[], [5], [5,4], [5,7], [2,6], [3,1,2], [4], [3]] expected output : 5
 * 
 * image1 Removing the number 2 city would split the graph into 2 isolated
 * islands, but removing the city number 5 would split the graph into 3 isolated
 * islands so your function should return 5;
 * 
 * Example 2
 * 
 * [[3,1], [0,2,5], [1,3,4,6], [0,2,6], [2,6], [1,7], [2,3,4], [5]] expected
 * output : 1
 * 
 * image2 Although it might seems that removing the city with most connection
 * which is in this case the city number 2 , removing the city number 1 would
 * split the graph into 2.
 * 
 * NOTE In case of the same number of isolated islands is generated by more than
 * one city, return the city with the lowest value i.
 */

solution = c => {
    let g = new Array(c.length).fill([])
    g = g.map(v => new Array(c.length).fill(0))
    
    c.map((v, i) => {
      v.map((e, j) => {
          g[i][e] = 1
          g[e][i] = 1
      })
    })

    g.map((v, i) => {
        c[i] = []
        v.map((e, j) => {
            if(e) c[i].push(j)
        })
    })

    const checkAmountIsolateIsland = (r, adj) => {
        let isVisited = new Set([r])
        
        const dfs = root => {
           isVisited.add(root)
           for(const e of c[root]){
               !isVisited.has(e) && dfs(e)
           }
        }
        
        let co = 0
        
        adj.map(e =>{
            if(!isVisited.has(e)) co++
            dfs(e)
        })
        
        return co
    }
    
    let m = 0, e = -1
    c.map((v, r) => {
        const a = checkAmountIsolateIsland(r, v)
        if(a > m){
            e = r
            m = a
        }
    })
    
    return e
}


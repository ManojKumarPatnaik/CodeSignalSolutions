<!DOCTYPE html>
<html>
<body>

<h2>The = Operator</h2>

<p id="demo"></p>

<script>

	
const EMPTY_BOARD = '.'
const BOARD_WIDTH = 10
const BOARD_HEIGHT = 20

isValidRange = ([r, c], [x, y]) => x > -1 && y > -1 && x < r && y < c
/**
 * 
 */
rotate = (piece) => {
    const pieceCoord = {
        rotate: 0,
        coords: [],
        contactsCoords: []
    }
    
    const firstX = piece[piece.length-1].findIndex(v => v !== EMPTY_BOARD)
    let startCoords = {coordsPiece: [piece.length - 1, firstX], convertedCoord: [0, 0]}
    const isVisited = new Set()
    
    convertPieceToCoords = (startCoords)=>{
        const y = startCoords.coordsPiece[0]
        const x = startCoords.coordsPiece[1]
        
        if(!isVisited.has(`${y}-${x}`)
          && isValidRange([piece.length, piece[0].length], startCoords.coordsPiece)
          && piece[y][x] !== EMPTY_BOARD){
           pieceCoord.coords.push([...startCoords.convertedCoord])
           isVisited.add(`${y}-${x}`)
           
           const DIRECTIONS = [[-1, 0], [0, -1], [0, -1], [0, 1]]
           for([a, b] of DIRECTIONS){
               const startCoordsCopy = {coordsPiece: [], convertedCoord: []}
               startCoordsCopy.coordsPiece[0] = startCoords.coordsPiece[0] + a
               startCoordsCopy.coordsPiece[1] = startCoords.coordsPiece[1] + b
               startCoordsCopy.convertedCoord[0] = startCoords.convertedCoord[0] + b
               // y coordinate
               // when +a then oxy with y is down
               //      -a when oxy is Cartersian
               startCoordsCopy.convertedCoord[1] = startCoords.convertedCoord[1] + a
               
               convertPieceToCoords(startCoordsCopy)
           }
        }
        
    }
    convertPieceToCoords(startCoords)
    
    getContactCoords = (coords) => {
        let coordsDistinct = new Set()
        coords.map(coord => coordsDistinct.add(`${coord[0]}-${coord[1]}`))
        return  [...coords.filter(c => !coordsDistinct.has(`${c[0]}-${c[1]+1}`))]
    }
    
    pieceCoord.contactsCoords = getContactCoords(pieceCoord.coords)
    
    // https://www.slideshare.net/VietTriEdu/cng-thc-php-quay-d-hiu
    rotateAngle = ([x, y], angle) => {
        toRadians = angle => angle * (Math.PI / 180);
        const xR = x * Math.cos(toRadians(angle)) - y * Math.sin(toRadians(angle))
        const yR = x * Math.sin(toRadians(angle)) + y * Math.cos(toRadians(angle))
        return [Math.round(xR), Math.round(yR)]
    }
    
    const pieceCoords = [pieceCoord]
    // rotate three time make three different shape when 
    for(let ind = 1; ind < 4; ind ++){
        const pieceCoordNext = {
            rotate: ind,
            coords: [...pieceCoords[ind-1].coords].map(c => rotateAngle(c, 90 * ind))
        }
        pieceCoordNext.contactsCoords = getContactCoords(pieceCoordNext.coords)
        pieceCoords.push(pieceCoordNext)
    }
    
    return pieceCoords
}
/**
 * 
 */
eatPoints = (board) => {
    let eatPointPosition = []
    
    board = board.map((row, y) => {
        const totalNotEmpty = row.filter(v => v !== EMPTY_BOARD)
        if(totalNotEmpty.length === BOARD_WIDTH){
            eatPointPosition.push(y)
        }
        return totalNotEmpty.length === BOARD_WIDTH ? new Array(BOARD_WIDTH).fill(EMPTY_BOARD) : row
    })
    
    // return [position, totalPoint]
    groupMaxPointPosition = (eatPointPosition) => {
        const newEatPointPosition = []
        for(let ind = 0; ind < eatPointPosition.length;){
            let pos = ind + 1
            while(pos < eatPointPosition.length && eatPointPosition[pos - 1] + 1 === eatPointPosition[pos]) pos++;
            newEatPointPosition.push([eatPointPosition[pos-1], pos - ind])
            pos === eatPointPosition.length - 1 &&	newEatPointPosition.push([eatPointPosition[pos], 1])
            ind += pos
        }
        
        return newEatPointPosition
    }
    
    eatPointPosition = groupMaxPointPosition(eatPointPosition)
    
     const point = eatPointPosition.reduce((t, v) => t += v[1], 0)
    console.log('eatPointPosition', eatPointPosition, point)
    
    let boardCopy = new Array(BOARD_HEIGHT).fill([])
    boardCopy = boardCopy.map(v => new Array(BOARD_WIDTH).fill(EMPTY_BOARD))
    
    console.log(eatPointPosition)
    eatPointPosition.map(stopPoint => {
        board.map((row, y) => row.map((v, x) => {
            if(v !== EMPTY_BOARD && y + stopPoint[1] <= stopPoint[0]){
                boardCopy[ y +  stopPoint[1]][x] = v
            }
        }))
    })
    
    if(eatPointPosition.length > 0){
        for(let ind = eatPointPosition[eatPointPosition.length - 1][0] + 1; ind < BOARD_HEIGHT; ind++){
            boardCopy[ind] = [...board[ind]]
        }
    }else{
        boardCopy = board.map(row => row.slice())
    }
    boardCopy.map(v => console.log(v.join("")))

    return { point, board: boardCopy }
}
/**
 * 
 */
callBestPlaceForPieceOnBoard = (board, pieceRotate, num) => {
    /**
     * After defined coords on board can put piece, next: 
     * 1, coords of piece must valid in boards range
     * 2, All of piece coordinates are not occupied by board
     * 3, One of contact coords is collision with other shape in board or is in botom of board
     */
    canPutPieceOnBoard = ([x, y], piece) => {
        const pieceMapping = [...piece.coords].map( coord => [coord[0] + x, coord[1] + y])
        const pieceContactMapping = [...piece.contactsCoords].map(coord => [coord[0] + x, coord[1] + y])
    
        // 1
        const notValidCoordInBoard = pieceMapping.filter(coord => !isValidRange([BOARD_WIDTH, BOARD_HEIGHT], coord))
        if(notValidCoordInBoard && notValidCoordInBoard.length > 0){
            return false
        }
        // 2
        const coordsIsOccupy = pieceMapping.filter(coord => board[coord[1]][coord[0]] !== EMPTY_BOARD)
        if(coordsIsOccupy && coordsIsOccupy.length > 0){
            return false
        }                  
        // 3
        const isCollision = pieceContactMapping.filter(coord => coord[1] + 1 === BOARD_HEIGHT || 
                                                        board[coord[1]+1][coord[0]] !== EMPTY_BOARD)
        if(!isCollision || isCollision.length === 0){
            return false
        }    
        
        return true
    }
    // 
    getAllPositionCanPutPiece = () =>{
        let y = BOARD_HEIGHT - 1
        const positions = []
        while(y > 0){
            for(let x = 0; x < BOARD_WIDTH; x++){
                if(board[y][x] === EMPTY_BOARD && (y + 1 >= BOARD_HEIGHT || 
                    board[y+1][x] !== EMPTY_BOARD)){
                    positions.push([x, y])
                }
            }
            y--
        }
        
        return positions
    }
    
    // The total number of blocks in the rows this piece will occupy after falling down is maximized;
    getTotalBlockPieceAggression = (coord, piece) => {
        let amount = 0
        const totalRow = new Set()
        const pieceMapping = [...piece.coords].map( c => [c[0] + coord[0], c[1] + coord[1]])
        pieceMapping.map(c => totalRow.add(c[1]))
        amount += piece.coords.length
        
        totalRow.forEach((key, value) => {
            const amountPiece = board[value].filter(v => v !== EMPTY_BOARD)
            amount += amountPiece.length
        })
        
        return amount
    }
        
    /**
     Find lowest positions and trying put piece to these position, piece can rotate 4 time,     
      each time has different shape, we need to check all cases
    */
    const appropriatePiece = {maxRowContact: 0, rotate: 0, boardPosition: [], coords: []}
    const validPositions = getAllPositionCanPutPiece()
    
    // TODO need to improve
	console.log("pieceRotate", JSON.stringify(pieceRotate))
	console.log("validPositions", JSON.stringify(validPositions))
    pieceRotate.map(piece => {
        validPositions.map(coord => {
            if(canPutPieceOnBoard(coord, piece)){
                const totalBlockPieceAggression = getTotalBlockPieceAggression(coord, piece)
				console.log('piÃªce', JSON.stringify(piece), totalBlockPieceAggression, coord)
                if(totalBlockPieceAggression > appropriatePiece.maxRowContact){
                    appropriatePiece.maxRowContact = totalBlockPieceAggression
                    appropriatePiece.rotate = piece.rotate
                    appropriatePiece.boardPosition = coord
                    appropriatePiece.coords = piece.coords
                }else if(totalBlockPieceAggression === appropriatePiece.maxRowContact){
                    if(appropriatePiece.rotate > piece.rotate){
                        appropriatePiece.maxRowContact = totalBlockPieceAggression
                        appropriatePiece.rotate = piece.rotate
                        appropriatePiece.boardPosition = coord
                        appropriatePiece.coords = piece.coords
                    }else if(appropriatePiece.rotate === piece.rotate){
                        if(appropriatePiece.boardPosition > coord[0]){
                            appropriatePiece.maxRowContact = totalBlockPieceAggression
                            appropriatePiece.rotate = piece.rotate
                            appropriatePiece.boardPosition = coord
                            appropriatePiece.coords = piece.coords
                        }
                    }
                }
            }
        })
    })
    
    // update to board
    appropriatePiece.coords.map(c =>{
        board[c[1] + appropriatePiece.boardPosition[1]][c[0] + appropriatePiece.boardPosition[0]] = num
    })
    return board;
}

tetrisGame = pieces => {
    const ALPHABET = 'abcdefghijklmnopqrstuvwxyz0123456789'.split('')
    let board = new Array(BOARD_HEIGHT).fill([])
    board = board.map(v => new Array(BOARD_WIDTH).fill(EMPTY_BOARD))
    
    let num = 0
    let point = 0
    pieces.map(piece =>{
        console.log("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@")
        const pieceRotate = rotate(piece)
        board = callBestPlaceForPieceOnBoard(board, pieceRotate, ALPHABET[num])
        
        const afterEatPoint = eatPoints(board)
        point += afterEatPoint.point
        board = afterEatPoint.board
        piece.map(v => console.log(v.join("")))
        num++
    })
    
    return point
}


/// test 
let pieces = [[[".","#","#"],["#","#","."]], 
 [[".","#","."],["#","#","#"]], 
 [["#","#","."],[".","#","#"]], 
 [[".","#","."],["#","#","#"]], 
 [["#","#","#","#"]], 
 [["#",".","."],["#","#","#"]], 
 [["#","#"],["#","#"]], 
 [["#","#","#"],[".",".","#"]], 
 [[".","#","#"],["#","#","."]], 
 [[".","#","."],["#","#","#"]], 
 [["#","#","."],[".","#","#"]], 
 [[".","#","."],["#","#","#"]], 
 [["#","#","#","#"]], 
 [["#",".","."],["#","#","#"]], 
 [["#","#"],["#","#"]], 
 [["#","#","#"],[".",".","#"]]]
 
 // tetrisGame(pieces)
 
 
 
 
 
 
    groupMaxPointPosition = (eatPointPosition) => {
	    console.log("input", eatPointPosition)
        const newEatPointPosition = []
        for(let ind = 0; ind < eatPointPosition.length;){
            let pos = ind
            while(pos < eatPointPosition.length - 1 && eatPointPosition[pos] + 1 === eatPointPosition[pos+1]) pos++
            newEatPointPosition.push([eatPointPosition[pos], pos - ind + 1])
            ind += (pos - ind) + 1
        }
        
        return newEatPointPosition
    }
	
	console.log(JSON.stringify(groupMaxPointPosition([1])))
	
	console.log(JSON.stringify(groupMaxPointPosition([1,2, 3])))
	
	console.log(JSON.stringify(groupMaxPointPosition([1, 3, 4, 7])))
	
	console.log(JSON.stringify(groupMaxPointPosition([1, 4, 7, 11, 23])))
 
    console.log(JSON.stringify(groupMaxPointPosition([1, 4, 7, 11, 12])))
	
	console.log(JSON.stringify(groupMaxPointPosition([1, 3])))
 
 
 
 
 
 
 
 
 
 
 
 
 
</script>

</body>
</html>
